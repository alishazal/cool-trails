<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cool Trails - Trail Details</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="/static/styles.css">
  <style>
    #map {
      height: 400px;
    }
  </style>
</head>
<body>
  <div class="container mt-4">
    <h1>{{trail.name}}</h1>
    <div class="alert alert-info d-flex align-items-center gap-2 py-2 px-3 mb-3">
      <span class="fw-bold">üìç Location:</span>
      <span class="text-muted">{{trail.location}}</span>
    </div>
    
    <!-- Map container -->
    <div id="map"></div>

    <!-- packing list container -->
    <div id="packingListContainer"></div>

    <!-- Start trail button -->
    <button class="btn btn-success mt-3">Start Trail</button>
    <a href="/search?q={{q}}" class="btn btn-secondary mt-3">Back to Search</a>
    <button id="getPackingRecs" class="btn btn-secondary mt-3">Get Packing Recs</button>
        <hr>

    <!-- Trail Info Card -->
    <div class="card shadow-sm mb-4">
      <div class="card-header bg-success text-white">
        <h5 class="mb-0">Trail Information</h5>
      </div>
      <div class="card-body p-0">
        <table class="table table-striped table-hover table-sm mb-0">
          <tbody>
            <tr>
              <th scope="row">üó∫Ô∏è Name</th>
              <td>{{trail_info.name}}</td>
            </tr>
            <tr>
              <th scope="row">üÜï Alternate Name</th>
              <td>{{trail_info.alt_name}}</td>
            </tr>
            <tr>
              <th scope="row">üõ£Ô∏è Highway Type</th>
              <td>{{trail_info.highway}}</td>
            </tr>
            <tr>
              <th scope="row">‚õ∞Ô∏è Incline</th>
              <td>{{trail_info.incline}}</td>
            </tr>
            <tr>
              <th scope="row">üåø Surface</th>
              <td>{{trail_info.surface}}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <h3 class="mt-5 mb-3">üìù Reviews</h3>

    {{#if reviews}}
      <div class="list-group">
        {{#each reviews}}
          <div class="list-group-item">
            <h5 class="mb-1">{{user_name}}</h5>
            <p class="mb-1">{{description}}</p>
            <small class="text-muted">Rating: {{stars}}</small>
          </div>
        {{/each}}
      </div>
    {{else}}
      <p class="text-muted">There are no reviews for this trail yet.</p>
    {{/if}}
    
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- point-in-polygon helper -->
  <script src="https://unpkg.com/leaflet-pip@1.1.0/leaflet-pip.min.js"></script>

  <script>
    async function getCurrentWeather(latitude, longitude) {
      const apiKey = 'e2cbf625af2a1df89cf399dcf091d050'; // Replace with your actual API key
      const apiUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${apiKey}&units=metric`; // You can change 'metric' to 'imperial' for Fahrenheit

      try {
        const response = await fetch(apiUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Could not fetch weather data:', error);
        return null;
      }
    }

    async function getPackingRecsInput() {
      var lat = {{trail.center_lat}}; // Assuming these values are correctly injected
      var lon = {{trail.center_lng}};

      try {
        const weatherData = await getCurrentWeather(lat, lon);

        var weather_info = "";
        if (weatherData) {
          weather_info +=
            `Description: ${weatherData.weather[0].description}\n` +
            `Temperature: ${weatherData.main.temp}¬∞C\n` +
            `Feels like: ${weatherData.main.feels_like}¬∞C\n` +
            `Humidity: ${weatherData.main.humidity}%\n` +
            `Wind Speed: ${weatherData.wind.speed} m/s`;
        }

        var extra_info = weather_info
        const llm_input = 'Provide packing recommendations for the following trail: {{trail.name}}, given the following information:\n'
                          + extra_info
        
        console.log('LLM Input:', llm_input);

      } catch (error) {
        console.error('Error in getPackingRecs:', error);
      }
    }

    getPackingRecsInput();


    const getPackingRecsButton = document.getElementById('getPackingRecs');

    getPackingRecsButton.addEventListener('click', async () => {
        try {
            const llm_input = getPackingRecsInput
            const response = await fetch(`http://localhost:8000/trail/{{trail.id}}/packing_recs?llm_input=${encodeURIComponent(llm_input)}`); // Adjust URL if your FastAPI server is on a different port/host
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            const packingList = data['packing_recommendations']

            display_packing_recs(packingList)
        } catch (error) {
            console.error("Error fetching trail information:", error);
        }
    });

    function display_packing_recs(packingList) {
      const container = document.getElementById('packingListContainer');

      if (container) {
        container.innerHTML = ''
      }


      for (let i = 0; i < packingList.length; i++) {
        item = packingList[i]
        const itemDiv = document.createElement('div');
        itemDiv.classList.add('packing-item');
        
        for (const property in item) {
          
          if (item.hasOwnProperty(property)) {
            const span = document.createElement('span');
            span.classList.add(property);
            span.textContent = item[property] + ': ';
            itemDiv.appendChild(span);
          }

          container.appendChild(itemDiv);
        }
      }
    }




    /* ---------- helpers ---------- */
    function sunVector(lat, lng, date = new Date()) {
      const pos = SunCalc.getPosition(date, lat, lng);
      return { az: pos.azimuth, alt: pos.altitude };   // radians
    }

    async function cloudCover(lat, lng) {
      const url =
        `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&hourly=cloudcover&forecast_days=1`;
      const resp = await fetch(url);
      const data = await resp.json();
      const idx = data.hourly.time.indexOf(
        new Date().toISOString().slice(0, 13) + ":00"
      );
      return data.hourly.cloudcover[idx];              // %
    }

    /* ---------- initialise map ---------- */
    const map = L.map("map").setView([0, 0], 13);      // temp view (will recalc)

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "¬© OpenStreetMap contributors",
      maxZoom: 19,
    }).addTo(map);

    /* ---------- draw stored polygon ---------- */
    const trailPolygon = {{{trail.polygon}}};
    const polyLayer = L.geoJSON(trailPolygon, {
      style: { color: "#0077ff", weight: 10, opacity: 0.8 },
    }).addTo(map);

    // Auto-zoom to polygon if centre not supplied
    map.fitBounds(polyLayer.getBounds(), { padding: [20, 20] });
    const center = map.getCenter();                    // use this for API bbox

    /* ---------- dynamic shade logic ---------- */
    (async function () {
      // 1. derive a ~500 m bbox around the map centre
      const Œî = 0.004;                                 // ‚âà ~450 m in deg
      const bbox = `${center.lat - Œî},${center.lng - Œî},${center.lat + Œî},${center.lng + Œî}`;

      // 2. fetch OSM trail segments + canopy polygons
      const [trailFC, canopyFC] = await Promise.all([
        fetch(`/trails/osm?bbox=${bbox}`).then((r) => r.json()),
        fetch(`/canopy/osm?bbox=${bbox}`).then((r) => r.json()),
      ]);

      // 3. draw canopy and keep a reference for point-in-polygon tests
      const canopyLayer = L.geoJSON(canopyFC, {
        style: { color: "#228b22", fillOpacity: 0.35, weight: 5 },
      }).addTo(map);

      // 4. colour trail segments green/orange
      const shadeLayer = L.layerGroup().addTo(map);
      const altitudeThr = 15 * Math.PI / 180;          // 15¬∞
      const cloudThr = 70;                             // 70 %

      for (const feat of trailFC.features) {
        const coords = feat.geometry.coordinates;
        for (let i = 0; i < coords.length - 1; i++) {
          const [lon1, lat1] = coords[i];
          const [lon2, lat2] = coords[i + 1];
          const midLat = (lat1 + lat2) / 2;
          const midLon = (lon1 + lon2) / 2;

          const sun = sunVector(midLat, midLon);
          const cloudy = (await cloudCover(midLat, midLon)) > cloudThr;
          const underCanopy =
            leafletPip.pointInLayer([midLon, midLat], canopyLayer).length > 0;

          const shaded =
            cloudy ||
            (underCanopy && sun.altitude > -0.05) ||
            sun.altitude < altitudeThr;

          L.polyline(
            [
              [lat1, lon1],
              [lat2, lon2],
            ],
            {
              color: shaded ? "green" : "orange",
              weight: 10,
              opacity: 0.9,
            }
          ).addTo(shadeLayer);
        }
      }
    })();
  </script>

</body>
</html>
