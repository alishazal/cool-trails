<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cool Trails - Trail Details</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="/static/styles.css">
  <style>
    #map {
      height: 400px;
    }
  </style>
</head>
<body>
  <div class="container mt-4">
    <h1>{{trail.name}}</h1>
    <p>{{trail.description}}</p>
    <p><strong>Location:</strong> {{trail.location}}</p>
    
    <!-- Map container -->
    <div id="map"></div>

    <!-- packing list container -->
    <div id="packingListContainer"></div>

    <!-- Start trail button -->
    <button class="btn btn-success mt-3">Start Trail</button>
    <a href="/search?q={{q}}" class="btn btn-secondary mt-3">Back to Search</a>
    <button id="getPackingRecs" class="btn btn-secondary mt-3">Get Packing Recs</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- point-in-polygon helper -->
  <script src="https://unpkg.com/leaflet-pip@1.1.0/leaflet-pip.min.js"></script>

  <script>
    async function getCurrentWeather(latitude, longitude) {
      const apiKey = 'e2cbf625af2a1df89cf399dcf091d050'; // Replace with your actual API key
      const apiUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${apiKey}&units=metric`; // You can change 'metric' to 'imperial' for Fahrenheit

      try {
        const response = await fetch(apiUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Could not fetch weather data:', error);
        return null;
      }
    }

    async function getPackingRecs() {
      var lat = {{trail.center_lat}}; // Assuming these values are correctly injected
      var lon = {{trail.center_lng}};

      try {
        const weatherData = await getCurrentWeather(lat, lon);

        var weather_info = "";
        if (weatherData) {
          weather_info +=
            `Description: ${weatherData.weather[0].description}\n` +
            `Temperature: ${weatherData.main.temp}°C\n` +
            `Feels like: ${weatherData.main.feels_like}°C\n` +
            `Humidity: ${weatherData.main.humidity}%\n` +
            `Wind Speed: ${weatherData.wind.speed} m/s`;
        }

        var extra_info = weather_info
        const llm_input = 'Provide packing recommendations for the following trail: {{trail.name}}, given the following information:\n'
                          + extra_info
        
        console.log('LLM Input:', llm_input);

      } catch (error) {
        console.error('Error in getPackingRecs:', error);
      }
    }

    getPackingRecs();


    const getPackingRecsButton = document.getElementById('getPackingRecs');

    getPackingRecsButton.addEventListener('click', async () => {
        try {
            const response = await fetch("http://localhost:8000/trail/{{trail.id}}/packing_recs"); // Adjust URL if your FastAPI server is on a different port/host
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            console.log("Data from backend:", data); // Print the received data to the browser's console

            const packingList = {
              "t-shirts": "3 items",
              "pants": "2 items",
              "socks": "5 pairs",
              "underwear": "5 pairs",
              "jacket": "1 item",
              "raincoat": "1 item",
              "backpack": "1 item"
            };


            display_packing_recs(packingList)
        } catch (error) {
            console.error("Error fetching trail information:", error);
        }
    });

    function display_packing_recs(packingList) {
      const container = document.getElementById('packingListContainer');
      for (const itemName in packingList) {
        if (packingList.hasOwnProperty(itemName)) {
          const itemDiv = document.createElement('div');
          itemDiv.classList.add('packing-item');

          const nameSpan = document.createElement('span');
          nameSpan.classList.add('item-name');
          nameSpan.textContent = itemName + ': ';

          const quantitySpan = document.createElement('span');
          quantitySpan.classList.add('item-quantity');
          quantitySpan.textContent = packingList[itemName];

          itemDiv.appendChild(nameSpan);
          itemDiv.appendChild(quantitySpan);
          container.appendChild(itemDiv);
        }
      }
    }




    /* ---------- helpers ---------- */
    function sunVector(lat, lng, date = new Date()) {
      const pos = SunCalc.getPosition(date, lat, lng);
      return { az: pos.azimuth, alt: pos.altitude };   // radians
    }

    async function cloudCover(lat, lng) {
      const url =
        `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&hourly=cloudcover&forecast_days=1`;
      const resp = await fetch(url);
      const data = await resp.json();
      const idx = data.hourly.time.indexOf(
        new Date().toISOString().slice(0, 13) + ":00"
      );
      return data.hourly.cloudcover[idx];              // %
    }

    /* ---------- initialise map ---------- */
    const map = L.map("map").setView([0, 0], 13);      // temp view (will recalc)

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "© OpenStreetMap contributors",
      maxZoom: 19,
    }).addTo(map);

    /* ---------- draw stored polygon ---------- */
    const trailPolygon = {{{trail.polygon}}};
    const polyLayer = L.geoJSON(trailPolygon, {
      style: { color: "#0077ff", weight: 3, opacity: 0.6 },
    }).addTo(map);

    // Auto-zoom to polygon if centre not supplied
    map.fitBounds(polyLayer.getBounds(), { padding: [20, 20] });
    const center = map.getCenter();                    // use this for API bbox

    /* ---------- dynamic shade logic ---------- */
    (async function () {
      // 1. derive a ~500 m bbox around the map centre
      const Δ = 0.004;                                 // ≈ ~450 m in deg
      const bbox = `${center.lat - Δ},${center.lng - Δ},${center.lat + Δ},${center.lng + Δ}`;

      // 2. fetch OSM trail segments + canopy polygons
      const [trailFC, canopyFC] = await Promise.all([
        fetch(`/trails/osm?bbox=${bbox}`).then((r) => r.json()),
        fetch(`/canopy/osm?bbox=${bbox}`).then((r) => r.json()),
      ]);

      // 3. draw canopy and keep a reference for point-in-polygon tests
      const canopyLayer = L.geoJSON(canopyFC, {
        style: { color: "#228b22", fillOpacity: 0.35, weight: 0 },
      }).addTo(map);

      // 4. colour trail segments green/orange
      const shadeLayer = L.layerGroup().addTo(map);
      const altitudeThr = 15 * Math.PI / 180;          // 15°
      const cloudThr = 70;                             // 70 %

      for (const feat of trailFC.features) {
        const coords = feat.geometry.coordinates;
        for (let i = 0; i < coords.length - 1; i++) {
          const [lon1, lat1] = coords[i];
          const [lon2, lat2] = coords[i + 1];
          const midLat = (lat1 + lat2) / 2;
          const midLon = (lon1 + lon2) / 2;

          const sun = sunVector(midLat, midLon);
          const cloudy = (await cloudCover(midLat, midLon)) > cloudThr;
          const underCanopy =
            leafletPip.pointInLayer([midLon, midLat], canopyLayer).length > 0;

          const shaded =
            cloudy ||
            (underCanopy && sun.altitude > -0.05) ||
            sun.altitude < altitudeThr;

          L.polyline(
            [
              [lat1, lon1],
              [lat2, lon2],
            ],
            {
              color: shaded ? "green" : "orange",
              weight: 6,
              opacity: 0.9,
            }
          ).addTo(shadeLayer);
        }
      }
    })();
  </script>

</body>
</html>
